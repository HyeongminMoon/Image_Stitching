<head>
    <style>
      @import url(//fonts.googleapis.com/earlyaccess/jejumyeongjo.css);

      .jm-font{
          font-family: 'Jeju Myeongjo', serif;/*웹 폰트 지정*/
          color: black;
      }
      .b {
        background-color: #BBDEFB;
        padding: 10px 20px;
      }
    </style>
</head>

{% if page.title == "Home" %}

<h5 class="jm-font"> <b>머리말</b> </h5>
<p class="jm-font"> - 이미지 스티칭은 이미지를 이어 붙이는 것을 의미한다. 자주 쓰지는 않지만 스마트폰 카메라에 파노라마 기능이 그 예시이다. 또는 고화질 이미지가 필요할 때 쓰이기도 한다.
    1080p화질의 카메라를 가지고 있어도 잘만 이어붙인다면 고화질의 이미지를 만들 수 있을 것이다.</p>
<p class="jm-font"> - 파노라마 기술은 어떻게 구현했을까? 카메라 렌즈에 왜곡이 있기 때문에 단순히 가로로 이어붙인다고 되는 게 아닌 것을 알 것이다. 이번에는 이미지 스티칭의 과정과
    중간중간 딥러닝을 활용하여 커스텀하는 방법에 대해 설명한다.</p>
<br></br>

<h5 class="jm-font"> <b>이미지 스티칭 과정</b> </h5>
<p class="jm-font"> - 이미지 스티칭은 다음 순서로 진행된다. 1. 두 이미지의 키포인트를 뽑는다. 2. 뽑은 키포인트 주변의 디스크립터(특징벡터)를 뽑는다. 3. 이 두가지를 가지고 키포인트 매칭을 하여
    두 이미지 사이의 전치행렬을 구한다. 4. 전치행렬을 적용시켜 합친다. 부가적으로 밝기조절, 빈 공간 처리 등을 진행한다. </p>
<p class="jm-font"> - Opencv에서는 이 모든 과정을 SIFT, ORB 등의 유명한 알고리즘들로 구현해 놓았다. 각 알고리즘의 detectAndCompute 함수를 사용하면 알아서 위 과정을 적용한다. 왠만한 이미지는
    이 방법으로 해결된다. 하지만 당연히 안되는 경우가 있다. 키포인트가 추출이 어려운 단순한 이미지인 경우, 또한 너무 단순해서 특징벡터에서 차별점을 찾기 어려운 경우 등이 있다. 나는 배경+단색의
    셀로 이루어진 매우 간단한 연료전지 시편 판 이미지들을 이어붙어야 했는데, 이 경우가 그랬다.</p>
<p class="jm-font"> - 따라서 성능향상을 위해 이 모든 구간에 딥러닝을 적용할 수 있다. 늘 반복하여 말하지만 딥러닝은 하나의 도구이다. 구글에서 연구된 각 과정에 딥러닝을 활용하여 만든
    DELF라는 모델이 있다. 적용해 보니 여전히 이미지가 너무 단순하여 매칭이 잘 안되는 모습을 볼 수 있다.</p>
<img src="https://user-images.githubusercontent.com/32811724/156486140-818c3965-2b51-49e4-8ffe-4ef7a6f0f92f.png" width="45%"></img>
<br></br>

<h5 class="jm-font"> <b>커스텀 스티칭</b> </h5>
<p class="jm-font"> - 다시 순정 SIFT에서부터 시작하기로 했다. 이미지를 좌측에서 우측으로 이동하며 촬영했으므로 좌측 이미지의 왼쪽과 우측 이미지의 오른쪽 부분은 필요 없다. 우선 이 부분을
    제외하고 매치 이미지를 그려보았다.</p>
<img src="https://user-images.githubusercontent.com/32811724/156486208-fbf5c709-2dfe-4f4d-ac6b-c0e739a58d93.JPG" width="45%"></img>
<p class="jm-font"> - 난잡하다. 맞는 것보다 안맞는 것이 더 많지만 맞는 것들이 보인다는 게 희망적으로 느껴졌다. 여담으로 이 이미지를 보고 다른 팀원들은 디스크립터 추출에 딥러닝을 사용하자고
    입을 모아서 그렇게 진행했으나, 실패했다. 따라서 나는 이 매치를 필터링하는 방법을 시도해볼 수 있는 시간을 달라고 제안했고, BF Matcher와 Knn match 알고리즘, 그리고 여러가지 thresholding으로
    해결했다. 그리하여 필터링된 매칭은 다음과 같다.</p>
<img src="https://user-images.githubusercontent.com/32811724/156486210-f1c93a01-2d12-4e46-8d14-7f62bb68c2e0.JPG" width="45%"></img>
<p class="jm-font"> - 여전히 노이즈가 있지만 이제 규칙이 보이기 시작했다. mean이나 median을 구해 그대로 적용해도 왠만한 경우에 잘 들어맞는다. </p>
<br></br>

<script src="https://utteranc.es/client.js"
        repo="HyeongminMoon/FRCNN_trademark_similarity"
        issue-term="title"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>


<div class="row g-5 mb-5" style="text-align:left">
<hr width = "90%" color = "black">
<h5> 관련 포스팅 </h5>
      {% for item in site.data.publications.featured %}
        <p><a href="{{ item.url }}">{{ item.name }}</a></p>
      {% endfor %}
    {% else %}
      includes publications.html
      {% for item in site.data.publications.index %}
        <p><a href="{{ item.url }}">{{ item.name }}</a></p>
      {% endfor %}
    {% endif %}
</div>
